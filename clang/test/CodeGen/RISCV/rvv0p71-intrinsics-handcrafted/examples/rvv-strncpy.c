// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 2
// RUN: %clang_cc1 -triple riscv64 -target-feature +xtheadvector \
// RUN:   -disable-O0-optnone -emit-llvm %s -o - | \
// RUN:   opt -S -passes=mem2reg | \
// RUN:   FileCheck --check-prefix=CHECK-IR %s

#include <riscv_vector.h>

// CHECK-IR-LABEL: define dso_local ptr @strncpy_vec
// CHECK-IR-SAME: (ptr noundef [[DESTINATION:%.*]], ptr noundef [[SOURCE:%.*]], i64 noundef [[COUNT:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-IR-NEXT:  entry:
// CHECK-IR-NEXT:    br label [[FOR_COND:%.*]]
// CHECK-IR:       for.cond:
// CHECK-IR-NEXT:    [[SRC_0:%.*]] = phi ptr [ [[SOURCE]], [[ENTRY:%.*]] ], [ [[ADD_PTR:%.*]], [[FOR_INC:%.*]] ]
// CHECK-IR-NEXT:    [[DST_0:%.*]] = phi ptr [ [[DESTINATION]], [[ENTRY]] ], [ [[ADD_PTR2:%.*]], [[FOR_INC]] ]
// CHECK-IR-NEXT:    [[COUNT_ADDR_0:%.*]] = phi i64 [ [[COUNT]], [[ENTRY]] ], [ [[SUB:%.*]], [[FOR_INC]] ]
// CHECK-IR-NEXT:    [[FIRST_SET_BIT_0:%.*]] = phi i64 [ -1, [[ENTRY]] ], [ [[TMP6:%.*]], [[FOR_INC]] ]
// CHECK-IR-NEXT:    [[VL_0:%.*]] = phi i64 [ undef, [[ENTRY]] ], [ [[TMP3:%.*]], [[FOR_INC]] ]
// CHECK-IR-NEXT:    [[CMP:%.*]] = icmp slt i64 [[FIRST_SET_BIT_0]], 0
// CHECK-IR-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK-IR:       for.body:
// CHECK-IR-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[COUNT_ADDR_0]], 0
// CHECK-IR-NEXT:    br i1 [[CMP1]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
// CHECK-IR:       if.then:
// CHECK-IR-NEXT:    br label [[RETURN:%.*]]
// CHECK-IR:       if.end:
// CHECK-IR-NEXT:    [[TMP0:%.*]] = call i64 @llvm.riscv.th.vsetvl.i64(i64 [[COUNT_ADDR_0]], i64 0, i64 0)
// CHECK-IR-NEXT:    [[TMP1:%.*]] = call { <vscale x 8 x i8>, i64 } @llvm.riscv.th.vleff.nxv8i8.i64(<vscale x 8 x i8> poison, ptr [[SRC_0]], i64 [[TMP0]])
// CHECK-IR-NEXT:    [[TMP2:%.*]] = extractvalue { <vscale x 8 x i8>, i64 } [[TMP1]], 0
// CHECK-IR-NEXT:    [[TMP3]] = extractvalue { <vscale x 8 x i8>, i64 } [[TMP1]], 1
// CHECK-IR-NEXT:    [[TMP4:%.*]] = call <vscale x 8 x i1> @llvm.riscv.th.vmseq.nxv8i8.i8.i64(<vscale x 8 x i8> [[TMP2]], i8 0, i64 [[TMP3]])
// CHECK-IR-NEXT:    [[TMP5:%.*]] = call <vscale x 8 x i1> @llvm.riscv.th.vmsif.nxv8i1.i64(<vscale x 8 x i1> [[TMP4]], i64 [[TMP3]])
// CHECK-IR-NEXT:    call void @llvm.riscv.th.vse.mask.nxv8i8.i64(<vscale x 8 x i8> [[TMP2]], ptr [[DST_0]], <vscale x 8 x i1> [[TMP5]], i64 [[TMP3]])
// CHECK-IR-NEXT:    [[TMP6]] = call i64 @llvm.riscv.th.vmfirst.nxv8i1.i64(<vscale x 8 x i1> [[TMP4]], i64 [[TMP3]])
// CHECK-IR-NEXT:    br label [[FOR_INC]]
// CHECK-IR:       for.inc:
// CHECK-IR-NEXT:    [[SUB]] = sub i64 [[COUNT_ADDR_0]], [[TMP3]]
// CHECK-IR-NEXT:    [[ADD_PTR]] = getelementptr inbounds i8, ptr [[SRC_0]], i64 [[TMP3]]
// CHECK-IR-NEXT:    [[ADD_PTR2]] = getelementptr inbounds i8, ptr [[DST_0]], i64 [[TMP3]]
// CHECK-IR-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4:![0-9]+]]
// CHECK-IR:       for.end:
// CHECK-IR-NEXT:    [[SUB3:%.*]] = sub i64 [[VL_0]], [[FIRST_SET_BIT_0]]
// CHECK-IR-NEXT:    [[ADD:%.*]] = add i64 [[COUNT_ADDR_0]], [[SUB3]]
// CHECK-IR-NEXT:    [[IDX_NEG:%.*]] = sub i64 0, [[SUB3]]
// CHECK-IR-NEXT:    [[ADD_PTR4:%.*]] = getelementptr inbounds i8, ptr [[DST_0]], i64 [[IDX_NEG]]
// CHECK-IR-NEXT:    [[TMP7:%.*]] = call i64 @llvm.riscv.th.vsetvlmax.i64(i64 0, i64 0)
// CHECK-IR-NEXT:    [[TMP8:%.*]] = call <vscale x 8 x i8> @llvm.riscv.th.vmv.v.x.nxv8i8.i64(<vscale x 8 x i8> poison, i8 0, i64 [[TMP7]])
// CHECK-IR-NEXT:    br label [[DO_BODY:%.*]]
// CHECK-IR:       do.body:
// CHECK-IR-NEXT:    [[DST_1:%.*]] = phi ptr [ [[ADD_PTR4]], [[FOR_END]] ], [ [[ADD_PTR7:%.*]], [[DO_COND:%.*]] ]
// CHECK-IR-NEXT:    [[COUNT_ADDR_1:%.*]] = phi i64 [ [[ADD]], [[FOR_END]] ], [ [[SUB6:%.*]], [[DO_COND]] ]
// CHECK-IR-NEXT:    [[TMP9:%.*]] = call i64 @llvm.riscv.th.vsetvl.i64(i64 [[COUNT_ADDR_1]], i64 0, i64 0)
// CHECK-IR-NEXT:    call void @llvm.riscv.th.vse.nxv8i8.i64(<vscale x 8 x i8> [[TMP8]], ptr [[DST_1]], i64 [[TMP9]])
// CHECK-IR-NEXT:    [[SUB6]] = sub i64 [[COUNT_ADDR_1]], [[TMP9]]
// CHECK-IR-NEXT:    [[ADD_PTR7]] = getelementptr inbounds i8, ptr [[DST_1]], i64 [[TMP9]]
// CHECK-IR-NEXT:    br label [[DO_COND]]
// CHECK-IR:       do.cond:
// CHECK-IR-NEXT:    [[CMP8:%.*]] = icmp ugt i64 [[SUB6]], 0
// CHECK-IR-NEXT:    br i1 [[CMP8]], label [[DO_BODY]], label [[DO_END:%.*]], !llvm.loop [[LOOP6:![0-9]+]]
// CHECK-IR:       do.end:
// CHECK-IR-NEXT:    br label [[RETURN]]
// CHECK-IR:       return:
// CHECK-IR-NEXT:    ret ptr [[DESTINATION]]
//
char *strncpy_vec(char *destination, char *source, size_t count) {
  unsigned char *dst = (unsigned char*)destination;
  unsigned char *src = (unsigned char*)source;
  long first_set_bit = -1;
  size_t vl;
  for (; first_set_bit < 0; count -= vl, src += vl, dst += vl) {
    if (count == 0)
      return destination;

    vl = __riscv_vsetvl_e8m1(count);
    vuint8m1_t vec_src = __riscv_vle8ff_v_u8m1(src, &vl, vl);

    vbool8_t string_terminate = __riscv_vmseq_vx_u8m1_b8(vec_src, 0, vl);
    vbool8_t mask = __riscv_vmsif_m_b8(string_terminate, vl);

    __riscv_vse8_v_u8m1_m(mask, dst, vec_src, vl);

    first_set_bit = __riscv_vfirst_m_b8(string_terminate, vl);
  }

  size_t tail = vl - first_set_bit;
  count += tail;
  dst -= tail;
  size_t vlmax = __riscv_vsetvlmax_e8m1();
  vuint8m1_t vec_zero = __riscv_vmv_v_x_u8m1(0, vlmax);
  do {
    size_t vl = __riscv_vsetvl_e8m1(count);
    __riscv_vse8_v_u8m1(dst, vec_zero, vl);
    count -= vl;
    dst += vl;
  } while (count > 0);

  return destination;
}
