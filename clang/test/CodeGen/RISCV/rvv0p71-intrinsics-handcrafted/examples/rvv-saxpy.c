// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 2
// RUN: %clang_cc1 -triple riscv64 -target-feature +xtheadvector \
// RUN:   -disable-O0-optnone -emit-llvm %s -o - | \
// RUN:   opt -S -passes=mem2reg | \
// RUN:   FileCheck --check-prefix=CHECK-IR %s

#include <riscv_vector.h>

// CHECK-IR-LABEL: define dso_local void @saxpy_vec
// CHECK-IR-SAME: (i64 noundef [[N:%.*]], float noundef [[A:%.*]], ptr noundef [[X:%.*]], ptr noundef [[Y:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-IR-NEXT:  entry:
// CHECK-IR-NEXT:    br label [[FOR_COND:%.*]]
// CHECK-IR:       for.cond:
// CHECK-IR-NEXT:    [[X_ADDR_0:%.*]] = phi ptr [ [[X]], [[ENTRY:%.*]] ], [ [[ADD_PTR:%.*]], [[FOR_INC:%.*]] ]
// CHECK-IR-NEXT:    [[Y_ADDR_0:%.*]] = phi ptr [ [[Y]], [[ENTRY]] ], [ [[ADD_PTR1:%.*]], [[FOR_INC]] ]
// CHECK-IR-NEXT:    [[N_ADDR_0:%.*]] = phi i64 [ [[N]], [[ENTRY]] ], [ [[SUB:%.*]], [[FOR_INC]] ]
// CHECK-IR-NEXT:    [[CMP:%.*]] = icmp ugt i64 [[N_ADDR_0]], 0
// CHECK-IR-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK-IR:       for.body:
// CHECK-IR-NEXT:    [[TMP0:%.*]] = call i64 @llvm.riscv.th.vsetvl.i64(i64 [[N_ADDR_0]], i64 2, i64 3)
// CHECK-IR-NEXT:    [[TMP1:%.*]] = call <vscale x 16 x float> @llvm.riscv.th.vle.nxv16f32.i64(<vscale x 16 x float> poison, ptr [[X_ADDR_0]], i64 [[TMP0]])
// CHECK-IR-NEXT:    [[TMP2:%.*]] = call <vscale x 16 x float> @llvm.riscv.th.vle.nxv16f32.i64(<vscale x 16 x float> poison, ptr [[Y_ADDR_0]], i64 [[TMP0]])
// CHECK-IR-NEXT:    [[TMP3:%.*]] = call <vscale x 16 x float> @llvm.riscv.th.vfmacc.nxv16f32.f32.i64(<vscale x 16 x float> [[TMP2]], float [[A]], <vscale x 16 x float> [[TMP1]], i64 7, i64 [[TMP0]])
// CHECK-IR-NEXT:    call void @llvm.riscv.th.vse.nxv16f32.i64(<vscale x 16 x float> [[TMP3]], ptr [[Y_ADDR_0]], i64 [[TMP0]])
// CHECK-IR-NEXT:    br label [[FOR_INC]]
// CHECK-IR:       for.inc:
// CHECK-IR-NEXT:    [[SUB]] = sub i64 [[N_ADDR_0]], [[TMP0]]
// CHECK-IR-NEXT:    [[ADD_PTR]] = getelementptr inbounds float, ptr [[X_ADDR_0]], i64 [[TMP0]]
// CHECK-IR-NEXT:    [[ADD_PTR1]] = getelementptr inbounds float, ptr [[Y_ADDR_0]], i64 [[TMP0]]
// CHECK-IR-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4:![0-9]+]]
// CHECK-IR:       for.end:
// CHECK-IR-NEXT:    ret void
//
void saxpy_vec(size_t n, const float a, const float *x, float *y) {
  for (size_t vl; n > 0; n -= vl, x += vl, y += vl) {
    vl = __riscv_vsetvl_e32m8(n);
    vfloat32m8_t vx = __riscv_vle32_v_f32m8(x, vl);
    vfloat32m8_t vy = __riscv_vle32_v_f32m8(y, vl);
    __riscv_vse32_v_f32m8(y, __riscv_vfmacc_vf_f32m8(vy, a, vx, vl), vl);
  }
}
